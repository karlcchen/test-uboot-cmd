#!/bin/bash
#
trim_line() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   
    echo -n "$var"
}
   
ID_UBOOT_ENV_SRC="#@!"   
ID_UBOOT_ENV_CMD="#@#"
ID_HOST_CMD="#@"

FILE_REV_MAJOR=2
FILE_REV_MINOR=0
DEST_SCR_WINDOW=0 
CMD_DELAY_SEC=2
LINE_NUM=0
OUTPUT_CMD_FILE="temp_u-boot-env.cmd.txt"
B_OVER_WRITE=0

if [ "${1}" = "-f" ] ; then 
    B_OVER_WRITE=1
    shift 1
fi 

if [ ! -z "${1}" ] ; then 
    UBOOT_CMD_FILE="${1}"
else
    printf "\nERROR1: No input file specified!\n" 
    exit 1
fi 

if [ ! -z "$2" ] ; then 
    OUTPUT_CMD_FILE="${2}"
fi 

if [ -f "${OUTPUT_CMD_FILE}" ] ; then    
    if [ ${B_OVER_WRITE} -eq 0 ] ; then  
        read -p "WARNING: output file '${OUTPUT_CMD_FILE}' exists, overwrite? (Yes/No):" -n 1 -r
        echo  # (optional) move to a new line
        if [[ ! $REPLY =~ ^[Yy]$ ]] ; then
            printf "\n ERROR2: Operation aborted by user!\n"
	    exit 2
        fi
    else
        printf "WARNING: output file %s exist and removed!\n" "${OUTPUT_CMD_FILE}"
    fi
    rm -f ${OUTPUT_CMD_FILE}
    if [ $? -ne 0 ] ; then 
        printf "\nERROR3: remove file %s failed!\n" "${OUTPUT_CMD_FILE}"
        exit 3
    fi 
fi 

# 
# 
printf "%s REV: %s.%s DATE: %s Generated by: \"%s\"\n" "${ID_UBOOT_ENV_CMD}" "${FILE_REV_MAJOR}" "${FILE_REV_MINOR}" "`date`" "cvt-cmd-4-screen.sh" >>${OUTPUT_CMD_FILE}
printf "%s Input: \"%s\" Output: \"%s\"\n" "${ID_UBOOT_ENV_CMD}" "${UBOOT_CMD_FILE}" "${OUTPUT_CMD_FILE}" >>${OUTPUT_CMD_FILE}

while IFS= read -r line_read
do
    LINE_NUM=$((LINE_NUM+1))
    line=`trim_line ${line_read}` 
    if [ ${LINE_NUM} -eq 1 ] ; then 
        ARG1=`echo "${line}" | awk '{print $1}'`
        if [ ! "${ARG1}" = "${ID_UBOOT_ENV_SRC}" ] ; then 
            printf "\nERROR4: uboot env file ID mismatched: \"%s\" != \"%s\"\n" "${ARG1}" "${ID_UBOOT_ENV_SRC}"  
            printf " DEBUG: line #%d= \"%s\"\n" ${LINE_NUM} "${line}" 
            exit 4
        fi  
        continue 
    fi  
    if [ ! "${line}" = "" ] ; then 
	if [[ ${line} =~ ^#.* ]] ; then 
# first non-space character is '#' 
	    ARG1=`echo "${line}" | awk '{print $1}'`
	    if [ "${ARG1}" = "${ID_HOST_CMD}" ] ; then 
		echo "${line}" | sed 's/\$/\\\\$/g' | sed "0,/'/s/'/\\\'/" | sed 's/\"/\\\"/g' | rev | sed "0,/'/s/'/'\\\/" | rev >>${OUTPUT_CMD_FILE}
	    fi 
	    continue 
	fi 
#
# prefix "$" with "\\$"
# change begin/end of single-quote ' to \'
# change begin/end of double-quote ' to \"
# but do not convert both singel/double quotes on the same line !
#
#	 printf "%s\n" "${line}" >>${OUTPUT_CMD_FILE} # RAW output 
        echo "${line}" | sed 's/\$/\\\\$/g' | sed "0,/'/s/'/\\\'/" | sed 's/\"/\\\"/g' | rev | sed "0,/'/s/'/'\\\/" | rev >>${OUTPUT_CMD_FILE}
#
#        echo ${line} | sed 's/\$/\\\\$/g' | sed "0,/'/s/'/\\\'/" | sed '0,/\"/s/\"/\\\"/' | rev | sed "0,/'/s/'/'\\\/" | sed '0,/\"/s/\"/\"\\/' | rev >>${OUTPUT_CMD_FILE}
#        echo ${line} | sed 's/\$/\\\\$/g' | sed "0,/'/s/'/\\\'/" | rev | sed "0,/'/s/'/'\\\/" | rev >>${OUTPUT_CMD_FILE}
	if [ $? -ne 0 ] ; then 
	    echo -e "\nERROR5: LINE #${LINE_NUM}, process '${line}' failed!\n"
	    exit 5
	fi 
    fi 
done < "${UBOOT_CMD_FILE}"
#
sync
printf "\n=== INFO: file: '%s' generated ===\n" ${OUTPUT_CMD_FILE}

